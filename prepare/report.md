# 论文阅读与前期工作总结
### 姓名：陈扬, 陈伟松, 牛凌宇, 陆记
### 学号：17343017，17343015, 17343091, 17343080
---
## 前期工作

### 使用示意图展示普通文件IO方式(fwrite等)的流程，即进程与系统内核，磁盘之间的数据交换如何进行？为什么写入完成后要调用fsync？
![普通io流程](img/1.png)

普通文件io方式通过缓冲区对文件进行间接操作以此提高文件读写效率,当进程fwrite写文件时,首先要向系统内核发出请求,系统内核再将数据存到缓冲区中,如果缓冲区未满,则不将缓冲区输出到磁盘文件中,一直到缓冲区满或者系统内核需要再次使用缓冲区时,才会将缓冲区文件写入.

调用fsync是因为普通文件io方式是一种延迟写策略,它并不是在要修改文件时即时修改,而是要等到缓冲区满或复用才会,以此减少写时间,提高效率,但是采用这种方式在系统异常退出时可能导致修改文件的数据留在缓冲区而没有即时存到磁盘文件的情况,在多进程情况下也会造成数据不一致的情况,调用fsync就是为了防止这些情况产生,fsync为文件写加锁,只有在文件写操作落实到磁盘文件上后才会解锁,它的作用在数据库系统中相当于是保证了数据的一致性.
### 简述文件映射的方式如何操作文件。与普通IO区别？为什么写入完成后要调用msync？文件内容什么时候被载入内存？
(使用什么函数，函数的工作流程)  
![文件映射操作文件](img/2.png)

与普通io的不同之处在与普通io是通过buffer来对文件进行间接操作,而文件映射是直接找到文件数据所在内存地址对内存进行操作,这样对大文件读写有大优势,且文件映射中用户空间和系统空间各自修改操作可以直接反映在映射的区域内,具有高效的交互性,方便实现内存共享,可以实现大文件的高效传输

调用msync是因为进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致.

MapViewOfFile（）时文件内容被载入内存

### 参考[Intel的NVM模拟教程](https://software.intel.com/zh-cn/articles/how-to-emulate-persistent-memory-on-an-intel-architecture-server)模拟NVM环境，用fio等工具测试模拟NVM的性能并与磁盘对比（关键步骤结果截图）。
（推荐Ubuntu 18.04LTS下配置，跳过内核配置，编译和安装步骤）

以root权限用vim打开grub文件  
![1](./img/3.1.png)  

打开后原grub文件是这样的  
![2](./img/3.2.png)  

修改，在GRUB_CMDLINE_LINUX_DEFAULT中加入memmap=2G!8G，用:wq!保存并退出  
![3](./img/3.3.png)  

为了方便创建超级用户root  
![4](./img/3.4.png)  

启动配置文件  
![5](./img/3.5.png)  

重启后，查看内存仿真  
![6](./img/3.6.png)  

查看内核中是否内置了 DAX 和 PMEM  
![8](./img/3.8.png)

安装包含 DAX 的文件系统，先创建文件夹  
![9](./img/3.9.png)  

然后制作文件系统  
![10](./img/3.10.png)  

映射，可以查看到pmem0  
![11](./img/3.11.png)  

在NVM上用fio测试性能  
![12](./img/3.12.png)

得出结果  
![13](./img/3.13.png)

在磁盘上用fio测试性能  
![14](./img/3.14.png)  

得出结果
![15](./img/3.15.png)  

可以看到NVM比磁盘快很多  

### 使用[PMDK的libpmem库](http://pmem.io/pmdk/libpmem/)编写样例程序操作模拟NVM（关键实验结果截图，附上编译命令和简单样例程序）。
（样例程序使用教程的即可，主要工作是编译安装并链接PMDK库）

目标是编译安装并链接PMDK库，先从github上clone下pmdk  
![1](./img/4.1.png)  

然后安装好下列pmdk所需要的包  
![2](./img/4.2.png)

检查版本  
![3](./img/4.3.png)  

编译安装  
![4](./img/4.4.png)  

链接  
![5](./img/4.5.png)  

加入到共享库配置文件，然后就可以编译运行程序了  
![6](./img/4.6.png)  

这里使用的程序是提供的样例程序如下：


---
## 论文阅读

### 总结一下本文的主要贡献和观点(500字以内)(不能翻译摘要)。
（回答本文工作的动机背景是什么，做了什么，有什么技术原理，解决了什么问题，其意义是什么）

XXXXXX

### SCM硬件有什么特性？与普通磁盘有什么区别？普通数据库以页的粒度读写磁盘的方式适合操作SCM吗？
XXXXXX
### 操作SCM为什么要调用CLFLUSH等指令？
(写入后不调用，发生系统崩溃有什么后果)  
XXXXXX

### FPTree的指纹技术有什么重要作用？
XXXXXX

### 为了保证指纹技术的数学证明成立，哈希函数应如何选取？
（哈希函数生成的哈希值具有什么特征，能简单对键值取模生成吗？）  
XXXXXX

### 持久化指针的作用是什么？与课上学到的什么类似？
XXXXXX
